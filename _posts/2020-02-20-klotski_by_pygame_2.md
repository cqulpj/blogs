---
layout: post
title:  "华容道游戏实现--破解算法"
author: lpj
categories: [ python, pygame ]
image: assets/images/10.jpg
tags: featured
---

上一篇博文实现的华容道游戏还有解密功能没有实现，这篇就来记录一下华容道破解算法的python实现。记得研一刚学python时用递归写过这个算法，横马立刀局耗时48秒左右，但用递归找到的不一定是最优解，所以这次用广（宽）度优先的搜索方法来写，确保找到的一定是最少步骤

## 一、棋局表示

这个是上一篇博文里有讲到，这里再重写阐述一下，华容道棋局的计算机表示有很多人研究过，在计算机资源较少时甚至用一个int型来表示一个棋局，缺点是不太直观，这里从以下几点来考虑华容道棋局的表示原则：
* 直观：棋局象征意义一目了然，不需要很复杂的转换关系
* 易于处理：比如生成下一步棋局，判断某个位置是什么角色等
* 通用性：不是只针对一种棋局或者一种角色搭配（比如只能处理1横4竖4小兵的棋局），要能描述所有的棋局

根据上述原则，这里用如下方式描述棋局：华容道棋盘看做xx4的二维数组，对于大将、曹操等对于1格的角色，用K、H、V表示其左上格元素，用S表示该角色的其他元素（占位符），用P表示小兵，用B表示空格，为了后续处理时易于处理，可以把K、V、H、B、P、S都定义为变量，这样一个棋局就是一个5x4的矩阵，示例代码如下：


> 棋局数据宏定义
> 对于多格角色，只有左上角格用K、H、V，其他占位格用S
> K = 7       # king，棋局中的'曹操'
> H = 2       # 长度为2的横向元素，棋局中的横向大将
> V = 3       # 长度为2的纵向元素，棋局中的纵向大奖
> P = 4       # 长宽都为1的元素，棋局中的小兵
> B = 0       # 长度都为1的空白位置
> S = 1       # 多个角色的占位格

> cp = [[P, K, S, P],
>      [V, S, S, V],
>      [S, H, S, S],
>      [H, S, H, S],
>      [B, P, P, B]]

这里之所以使用S（占位符），主要是为了在后续计算一个棋局的下一步所有可能棋局时，跳过这些位置的计算，降低计算量，但这样设计的缺点是破坏了棋局的对称性，有些华容道解法提出不计算对称棋局以提高效率，这里因为失去了对称性导致不能采用。还需要说明的是，有的研究者把大将（横向或者纵向两格的角色）还做了区分，比如纵向的还区分为赵云、黄忠、张飞等，数据也用不一样的表示，这样意义不大，本文未采用这种方式

## 二、下一步棋局计算

有了当前的棋局后，该怎么计算它下一步所有可能的棋局（走法）呢，其实这个很简单了，先遍历棋局数组，若遍历到的元素是K、V、H、P，就判断它朝上、下、左、右四个方向能否移动，能移动则得到它移动后的棋局数据，遍历完所有元素后，得到的所有下一步棋局就是当前棋局的所有子棋局，这里就体现我们上一节使用占位符的好处了，遍历到占位符直接跳过，省去了对一个角色重复处理的过程。

这里多说几局，如果用二维数组，角色能否移动的判断及移动后的数据这两个过程代码写起来非常非常繁琐，比如cp[i][j]是K，要判断它能否左移及求左移后的数代码如下：
```python
if (j>0) and (cp[i][j-1]==B) and (cp[i+1][j-1]==B):
    tn = copy.deepcoay(cp)
    tn[i][j-1:j+2] = [K, S, B]
    tn[i+1][j-1:j+2] = [S, S, B]
```

如果改成矩阵形式表示就写起来简单一些，比如先用np.asarray(cp)将cp变成numpy.array，然后再将进行上述过程，代码变为：
```python
if (i>0) and (cp[i:i+2, j-1]==[B, B]).all():
    tn = cp.copy()
    tn[r:r+2, c-1:c+2] = [[K, S, B], [S, S, B]]
```


## 三、算法流程

华容道解法从本质上都是穷举，即一步步得到所有的走法，直到出现'完成'状态（本文表示中当cp[3][1]为K）时结束搜索，从搜索方向分为广（宽）度优先和深度优先，如果要求最优解，只能选择广（宽）度优先策略，不考虑算法优化的话，算法步骤如下：

1. 将初始棋局cp存入当前层（第一层）R1=[ cp ]，i=1
2. 判断当前层Ri中的所有棋局有没有'完成'状态的，若有，则结束，没有则进行下一步
3. 遍历当前层Ri中的所有棋局，对每个棋局都得到其所有子棋局，存入R(i+1)层
4. i=i+1，执行步骤2

示意流程图如下：

<img src='/blogs/assets/images/klotski_basic_flow.png' height="500" align=center>


## 四、算法优化和细节

通过上一节的方法，理论上我们已经实现了华容道的求解，但如果编码运行会发现有几个问题：1、运行实际非常长，程序效率很低，该怎么优化？2、运行出来后，中间的过程没有记录，该怎么一步步记录中间的步骤？下面分别阐述：

1. **算法初步优化：**现在仔细回顾上述过程，我们发现生成子棋局的时候没有进行判断，即如果这个棋局已经在前面出现过，那就将它丢掉，不需要存入R(i+1)层，这样保证R中（全部层）所有棋局没有重复，好了，现在我们对上一节中的步骤3做了改动，改为：
> 遍历当前层Ri中的所有棋局，对每个棋局生成的每个子棋局CP，先在Rn（n=1...i+1）中进行查找，若已经存在，则丢弃，否则加入R(i+1)中

2. **算法的再度优化：**经过上一步优化后，程序求解时间大大缩短了，但还没达到我们的要求，我们再来审视一下，上一步中我们需要把子棋局CP跟Rn(n=1...i+1)中共i+1层进行比较，python中判断一个元素（可以是任何类型）m在不在列表list中，直接用`if m in list:`就行，但因为要比较i+1层，所以这里还是要比较i+1次，我们可以把所有层的数据放在一个列表中，然后用另外一个数组记录每一层的开始索引就行，下面代码中是两种表示的示意：

    ```python
    R = [[cp0],
         [cp10, cp11, cp12],
         [cp20, cp21, cp22, cp23, ...]]
    ...

    RL =  [cp0, cp10, cp11, cp12, cp20, cp21, cp22, cp23, ...]
    ids = [0, 1, 4, ...]
    ```

3. **算法的再再度优化：**现在程序运行时间又缩短了一些，但是还是不够快，横马立刀这种棋局需要180多秒，在游戏中别人点了解密要等待3分钟才出结果，这个……还是太low了点儿，嗯，再想想，如果你对程序运行耗时进行测试的话，会发现大部分时间都是耗在对子棋局判断是否已经出现过这个环节中，因为R中的棋局越来越多（正常棋局运算到后面生成的子棋局在4000-60000范围），每一次生成的新棋局也非常多，这个比较过程耗时太多了，那这里还有优化空间吗？嗯有，先说结论吧，生成的子棋局不需要跟前面所有层进行比较，只跟它前面两层（i层、i-1层）进行比较即可，证明过程如下：

> 假如第s层（s<i-1）层出现过当前待比较棋局cp，那么第s+1层一定有cp的父棋局，但是cp的父棋局在Ri中，且s+1<i，这说明第i层和第s+1层都出现了cp的父棋局，这个结论与R中无重复元素的设定矛盾，所以假设不成立，因此只i-1层之前不会有cp存在

4. **解法步骤的回溯：**经过上一步再再度优化，现在耗时应该到了可以接受（最多7秒）的程度了，当然还有优化空间，这里先不探讨了，我们说说怎么回溯求解过程中每一步走法（棋局），这个其实比较容易，只需对R（现在是个list，参见初步优化1）中每一个棋局记录一下它的父棋局索引，程序处理完后，从'完成'棋局找到它的父棋局，在往前一步步查找，直到开始棋局...

## 五、总结

好了，现在华容道求解算法完成了，把它加入到之前的游戏中，玩家可以点击“解密”来观看棋局的最优解法了，具体的工程（包含解密算法）请移步CSDN进行下载（[下载地址](https://download.csdn.net/download/xiaomiaolpj/12169543)），有其他要探讨的请邮件联系，邮箱:269499391@qq.com。
